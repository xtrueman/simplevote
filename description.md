Теперь создай серверную часть — сервис на FastAPI для голосования.
Оновной endpoint — для приёма результатов голосования.
Периситентного хранилища в сервиса не будет, хранение будет в памяти. Соответственно, запуск сервиса будет в рамках одного процесса.

1. endpoint для поллинга — можно ли уже голосовать за очередного человека:
`/status` — получить данные по очередной персоне за которую голосуем
Возвращает JSON: { "status": "VOTING", "personnum" : 1, "description" : "Имя / описание персоны за которую голосуем" }
`personnum` — номер человека за которого открыто голосование
`description` — Имя / описание персоны за которую голосуем.
Если голосование пока не началось, то возвращается { status: "VOTING_NOT_STARTED" }
Если голосование уже закончилось и можно объявлять результаты, то возвращается { status: "VOTING_FINISHED" }

2. endpoint для приёма результатов голосования:
`/vote?personnum=123&rating=5`
где personnum — номер человека за которого голосуем;
rating — оценка от 1 до 5.
Возвращает статус 200 если голосование прошло успешно или иной код если произошла ошибка, например если `personnum > current_person_num` или голсование уже завершено

3. `/setcurrenperson?description=...` — "админская" функция, которая разрешает голосование по очередной персоне,
вызывается с админского интерфейса.
description — Имя / описание персоны за которую голосуем
При этом сервер хранит номер участника, за которого мы сейчас голосуем (в переменной current_person_num). Номера участников начинаются с 1.
Если description = "VOTING_FINISHED" (специальное значени, что голосование завершено), то голосование завершается и отправить 

4. `/getresults` — получаем результаты голосования.
Но выходе рейтинг всех оцениваемых персон в JSON в порядке убывания рейтинга:
[ { "personnum" : 123, "description" : "Имя / описание персоны за которую голосуем", rating : 4.98 }, ... ]
Рейтинг рассчитывается как среднее между всеми оценками всех людей, которые проголосовали за данную персону (поскольку за данную персону могли проголосовать разное количество людей).


Соответственно, логика на стороне FrontEnd такая:
- вначале при заходе на страницу должна показываться заглушка "голосование пока не началось"
- страница каждые 500ms делает поллинг на endpoint `/status` для запроса статуса, пока status = "VOTING_NOT_STARTED", продолжаем выдавать заглушку
- как только статус будет "VOTING" — начинаем голосование, выдаётся основной интерфейс для голосования, только добавляется description с описанием того за кого голосуем (чтобы было понятно за кого голосуем) — под номером участника;
- при нажатии "Голосовать ещё" или "Далее" — результаты голосования отправляются в `/vote?personnum=123&rating=5`
При отправке результатов голсования мы проверяем статус возврата, если возвращется код отличный от 200, пишем сообщение "произошла ошибка".
- после нажатия "Далее" — вновь проверяем `/status` и проверяем статус пока personnum не увеличился по сравнению с предыдущим значением (то есть ожидаем пока не будет объявлено голосование за следующего человека), пока personnum не увеличился — то показываем заглушку "Ожидаем следующего участника", прододжаем делать polling каждые 500ms пока personnum не увеличится или пока пока статус не поменяется на "VOTING_FINISHED".

То есть после нажатия "Далее" у нас есть 3 варианта:
- status = "VOTING" и пока не объявлено голосование за следующего человека (personnum не увеличился по сравнению с тем за который мы уже проголсовали) — показываем заглушку "Ожидаем следующего участника"
- если status = "VOTING" и объявлен следующий участник (personnum увеличился) — стандартный интерфейс голосования, идёт голосование за следующего человека,
- если status="VOTING_FINISHED" — объявляем результаты, в данном случае делается запрос `/getresults` и отображаются результаты голосования — список в порядке убывания рейтинга;

При 